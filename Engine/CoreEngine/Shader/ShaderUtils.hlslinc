float4 Mask_R(float InColor)
{
	return float4(InColor, 0, 0, 1);
};

float4 Mask_G(float InColor)
{
	return float4(0, InColor, 0, 1);
};

float4 Mask_B(float InColor)
{
	return float4(0, 0, InColor, 1);
};

float4 Mask_A(float InColor)
{
	return float4(0, 0, 0, InColor);
};

/**
 * @brief 텍스처를 일정 속도로 x, y축으로 이동시키는 함수 (애니메이션 효과)
 * @param InTime : 게임 시간 (Delta Time 누적)
 */
float2 Panner(float2 InUV, float2 InSpeed, float InTime)
{
	// 시간 기반으로 Speed에 따라 UV 좌표를 이동시킨다.
	float2 uvOffset = InUV + InSpeed * InTime;

	// frac을 이용하여 0~1 사이의 값으로 정규화한다.
	uvOffset.x = frac(uvOffset.x);
	uvOffset.y = frac(uvOffset.y);

	return uvOffset;
};

float WorldAlignedBlend(float3 InPixelNormal, float InputBlendSharpness, float InputBlendBias)
{
	// Z 축을 기준으로 법선과의 각도를 측정
	float blendFactor = dot(normalize(InPixelNormal), float3(0, 0, 1));
    
	// blendFactor를 0.5로 스케일링하고 Offset을 적용
	blendFactor = blendFactor * 0.5f + 0.5f;
    
	// BlendSharpness와 BlendBias를 사용해 값 조정
	blendFactor = blendFactor * InputBlendSharpness + InputBlendBias;
    
	// 결과값을 0과 1 사이로 clamp
	return clamp(blendFactor, 0.0f, 1.0f);
	return clamp(
				 dot(InPixelNormal, float3(0, 0, 1)) * 0.5f + 0.5f * InputBlendSharpness + (InputBlendBias
				 - (InputBlendSharpness * 0.5f)),
				 0,
				 1);
}
