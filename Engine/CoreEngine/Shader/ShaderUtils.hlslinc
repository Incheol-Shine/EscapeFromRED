float4 Mask_R(float InColor)
{
	return float4(InColor, 0, 0, 1);
};

float4 Mask_G(float InColor)
{
	return float4(0, InColor, 0, 1);
};

float4 Mask_B(float InColor)
{
	return float4(0, 0, InColor, 1);
};

float4 Mask_A(float InColor)
{
	return float4(0, 0, 0, InColor);
};

/**
 * 버퍼로부터 본의 변환 행렬을 가져온다.
 */
float4x4 FetchBoneTransform(uint Bone, StructuredBuffer<float4> BoneTransforms)
{
	Bone *= 4;	// 4x4 행렬이므로 4를 곱해준다.
	float4 row1 = BoneTransforms.Load(Bone + 0);	// 4x4 행렬의 첫번째 행
	float4 row2 = BoneTransforms.Load(Bone + 1);	// 4x4 행렬의 두번째 행
	float4 row3 = BoneTransforms.Load(Bone + 2);	// 4x4 행렬의 세번째 행
	float4 row4 = BoneTransforms.Load(Bone + 3);	// 4x4 행렬의 네번째 행

	float4x4 Matrix = float4x4(row1, row2, row3, row4);	// 4x4 행렬 생성
	return Matrix;
}

/**
 * @brief 텍스처를 일정 속도로 x, y축으로 이동시키는 함수 (애니메이션 효과)
 * @param InTime : 게임 시간 (Delta Time 누적)
 */
float2 Panner(float2 InUV, float2 InSpeed, float InTime)
{
	// 시간 기반으로 Speed에 따라 TexCoord 좌표를 이동시킨다.
	float2 uvOffset = InUV + InSpeed * InTime;

	// frac을 이용하여 0~1 사이의 값으로 정규화한다.
	uvOffset.x = frac(uvOffset.x);
	uvOffset.y = frac(uvOffset.y);

	return uvOffset;
};

float WorldAlignedBlend(float3 InPixelNormal, float InputBlendSharpness, float InputBlendBias)
{
	// Z 축을 기준으로 법선과의 각도를 측정
	float blendFactor = dot(InPixelNormal, float3(0, -1, 0));

	// blendFactor를 0.5로 스케일링하고 Offset을 적용
	blendFactor = blendFactor * 0.5f + 0.5f;

	blendFactor = blendFactor * InputBlendSharpness;

	// BlendSharpness와 BlendBias를 사용해 값 조정
	blendFactor = blendFactor + (InputBlendBias - (InputBlendSharpness * 0.5f));


	// 결과값을 0과 1 사이로 clamp
	return clamp(blendFactor, 0.0f, 1.0f);
}

float3 ComputePointLight(float3      InWorldPos,
						 float3      InWorldNormal,
						 FPointLight InPointLight)
{
	// 빛의 방향을 계산
	float3 lightDir           = InPointLight.Position - InWorldPos;
	float3 lightDirNormalized = normalize(InPointLight.Position - InWorldPos);

	// 빛의 거리를 계산
	float lightDistance = length(lightDir);

	if (lightDistance > InPointLight.Range)
	{
		return float3(0, 0, 0);
	}

	// 빛의 강도를 계산
	float lightIntensity = saturate(1.0f - lightDistance / InPointLight.Range) * InPointLight.Intensity;

	// 빛의 강도를 계산
	float lightFactor = saturate(dot(InWorldNormal, lightDirNormalized));


	// 빛의 강도를 계산
	float3 lightColor = InPointLight.Color * lightIntensity * lightFactor;

	return lightColor;
}

float3 ComputeSpotLight(float3     InWorldPos,
						float3     InWorldNormal,
						FSpotLight InSpotLight)
{
	float3 lightDir           = InSpotLight.Position - InWorldPos;
	float3 lightDirNormalized = normalize(InSpotLight.Position - InWorldPos);
	float  lightDistance      = length(lightDir);

	if (lightDistance > InSpotLight.Range)
	{
		return float3(0, 0, 0);
	}

	float lightIntensity = saturate(1.0f - lightDistance / InSpotLight.Range) * InSpotLight.Intensity;
	float lightFactor    = saturate(dot(InWorldNormal, lightDirNormalized));

	float spotFactor  = dot(-lightDirNormalized, InSpotLight.Direction);
	float spotFactor2 = smoothstep(InSpotLight.SpotAngle, InSpotLight.SpotAngle * 0.9f, spotFactor);

	float3 lightColor = InSpotLight.Color * lightIntensity * lightFactor * spotFactor2;

	return lightColor;
}
